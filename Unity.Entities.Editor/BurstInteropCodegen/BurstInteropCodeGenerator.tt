<#@ template language="C#" inherits="CodeGeneratorBase"#>

//------------------------------------------------------------------------------
// <auto-generated>
//     This file was automatically generated by <#=GetType()#>
//     Any changes you make here will be overwritten
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//     To update this file, use the "DOTS -> Regenerate Burst Interop" menu option.
//
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using Unity.Burst;

namespace <#= StructType.Namespace #>
{
    <# if (StructType.IsPublic) {#>public<#}#> unsafe partial struct <#= StructType.Name #>
    {

#if !(NET_DOTS || (UNITY_2020_1_OR_NEWER && UNITY_IOS))
        static bool _initialized = false;

        [BurstDiscard]
        private static void CheckMono(ref bool isMono)
        {
            isMono = true;
        }

        private static bool IsMono()
        {
            bool result = false;
            CheckMono(ref result);
            return result;
        }

<#
foreach (var method in Methods)
{
#>
        private delegate <#= ReturnType(method) #> _dlg<#= method.Name #>(<#= Prototype(method) #>);
        private static _dlg<#= method.Name #> _bfp<#= method.Name #>;
<#}#>
#endif

        public static void Initialize()
        {
#if !(NET_DOTS || (UNITY_2020_1_OR_NEWER && UNITY_IOS))
            if (_initialized)
                return;
            _initialized = true;
<# foreach (var method in Methods) { #>
            _bfp<#= method.Name #> = BurstCompiler.CompileFunctionPointer<_dlg<#= method.Name #>>(_mono_to_burst<#= method.Name #>).Invoke;
<#}#>
#endif
        }

<# foreach (var method in Methods) { #>
        public static <#= ReturnType(method) #> <#= method.Name.Substring(1) #> (<#= Prototype(method) #>)
        {
#if !(NET_DOTS || (UNITY_2020_1_OR_NEWER && UNITY_IOS))
            if (IsMono())
            {
<#if (method.ReturnType == typeof(void)) {#>
                _forward_mono<#=method.Name#>(<#= CallArgs(method) #>);
                return;
<#} else {#>
                var _retval = default(<#=ReturnType(method)#>);
                _forward_mono<#=method.Name#>(ref _retval, <#= CallArgs(method) #>);
                return _retval;
<#}#>
            }
#endif

<#if (method.ReturnType == typeof(void)) {#>
            <#=method.Name#>(<#= CallArgs(method) #>);
<#} else {#>
            return <#=method.Name#>(<#= CallArgs(method) #>);
<#}#>
        }

#if !(NET_DOTS || (UNITY_2020_1_OR_NEWER && UNITY_IOS))
        [BurstCompile]
        [MonoPInvokeCallback(typeof(_dlg<#= method.Name #>))]
        private static <#= ReturnType(method) #> _mono_to_burst<#= method.Name #>(<#= Prototype(method) #>)
        {
<#if (method.ReturnType == typeof(void)) {#>
            <#=method.Name#>(<#= CallArgs(method) #>);
<#} else {#>
            return <#=method.Name#>(<#= CallArgs(method) #>);
<#}#>
        }

        [BurstDiscard]
<# if (method.ReturnType == typeof(void)) { #>
        private static void _forward_mono<#= method.Name #>(<#= Prototype(method) #>)
<#} else {#>
        private static void _forward_mono<#= method.Name #>(ref <#= ReturnType(method) #> _retval, <#= Prototype(method) #>)
<#}#>
        {
<#if (method.ReturnType == typeof(void)) {#>
            _bfp<#=method.Name#>(<#= CallArgs(method) #>);
<#} else {#>
            _retval = _bfp<#=method.Name#>(<#= CallArgs(method) #>);
<#}#>
        }
#endif

<#}#>
    }
}
